<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>BLPestimatoR - Package for Demand Estimation</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/github.min.css">
<script src="https://cdn.jsdelivr.net/combine/gh/highlightjs/cdn-release@11.6.0/build/highlight.min.js,npm/@xiee/utils/js/load-highlight.js" async></script>

<!-- MathJax scripts -->
<script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML" async>
</script>

<style type="text/css">
body, td {
  font-family: sans-serif;
  background-color: white;
  font-size: 13px;
}
body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
}
tt, code, pre {
  font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}
a:visited { color: #80007f; }
pre, img { max-width: 100%; }
code {
  font-size: 92%;
  border: 1px solid #ccc;
}
code[class] { background-color: #F8F8F8; }
code.language-undefined { background-color: inherit; }
table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
blockquote {
  color:#666;
  margin:0;
  padding-left: 1em;
  border-left: 0.5em #eee solid;
}
hr { border: 1px #ddd dashed; }

@media print {
  * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
  }
  body {
    font-size: 12pt;
    max-width: 100%;
  }
  a, a:visited { text-decoration: underline; }
  hr {
    visibility: hidden;
    page-break-before: always;
  }
  pre, blockquote {
    padding-right: 1em;
    page-break-inside: avoid;
  }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style>



</head>

<body>
<h1>Intro</h1>
<p><code>BLPestimatoR</code> provides an efficient estimation algorithm to perform the demand estimation described in @BLP1995. The routine uses analytic gradients and offers a large number of optimization routines and implemented integration methods as discussed in @Brunner2017.</p>
<p>This extended documentation demonstrates the steps of a typical demand estimation with the package:</p>
<ul>
<li>prepare the data with <code>BLP_data</code> (includes the specification of a model and providing integration draws for observed or unobserved heterogeneity)</li>
<li>estimate the parameters with <code>estimate_BLP</code></li>
<li>showing the results with <code>summary</code></li>
<li>view the own- and crosspriceelasticities with <code>get_elasticities</code></li>
<li>perform a hypothetical merger analysis</li>
</ul>
<p>For this purpose the well-known training datasets for the cereal market [@Nevo2001] and the car market [@BLP1995] are included in the package. Loading the package is therefore the very first step of the demand estimation:</p>
<pre><code class="language-r">library(BLPestimatoR)
</code></pre>
<h1>Data</h1>
<h2>Model</h2>
<p>Since version 0.1.6 the model is provided in R’s formula syntax and consists of five parts. The variable
to be explained is given by observed market shares. Explanatory variables are grouped into four (possibly
overlapping) categories separated by <code>|</code>:</p>
<ul>
<li>linear variables</li>
<li>exogenous variables</li>
<li>random coefficients</li>
<li>instruments</li>
</ul>
<p>The first part of this documentation starts with the cereal data example from @Nevo2001. Nevo’s model can be translated into the following formula syntax:</p>
<pre><code class="language-r">nevos_model &lt;- as.formula(&quot;share ~  price + productdummy |
    0+ productdummy |
    price + sugar + mushy |
    0+ IV1 + IV2 + IV3 + IV4 + IV5 + IV6 + IV7 + IV8 + IV9 + IV10 + 
    IV11 + IV12 + IV13 + IV14 + IV15 + IV16 + IV17 + IV18 + IV19 + IV20&quot;)
</code></pre>
<p>The model is directly related to consumer \(i\)’s indirect utility from purchasing cereal \(j\) in market \(t\):</p>
<p>$$u_{ijt}=\sum_{m=1}^M x^{(m)}_{jt} \beta_{i,m}+\xi_{jt}+\epsilon_{ijt} \;\; \text{with}$$
$$\beta_{i,m}= \bar{\beta}_m  + \sum_{r=1}^R  \gamma_{m,r} d_{i,r}  +  \sigma_m \nu_{i,m}$$
and</p>
<ul>
<li>M = 4 random coefficients (<code>price</code>, <code>sugar</code>, <code>mushy</code> and an intercept)</li>
<li>R = 4 demographics (<code>income</code>, <code>incomesq</code>, <code>age</code>, <code>child</code>)</li>
<li>and the set of non-linear parameters to estimate:</li>
</ul>
<p>$$\theta_2 =  \begin{pmatrix} \sigma_1 &amp; \gamma_{1,1} &amp; \cdots &amp; \gamma_{1,R} \\ \sigma_2 &amp; \gamma_{2,1} &amp; \cdots &amp; \gamma_{2,R} \\ \vdots &amp; \vdots &amp;  \ddots &amp; \vdots \\ \sigma_M &amp; \gamma_{M,1} &amp; \cdots &amp; \gamma_{M,R} \end{pmatrix}$$</p>
<h2>Dataframe</h2>
<p>Product related variables are collected in the dataframe <code>productData</code> with the following requirements:</p>
<ul>
<li>missings are not allowed</li>
<li>character variables are automatically transformed to a set of dummy variables</li>
<li>a variable that describes market affiliation (<code>market_identifier</code>)</li>
</ul>
<p>A variable that uniquely identifies a product in a market (<code>product_identifier</code>) is optional, but enhances clarity (interpreting elasticities, for example, is much easier). <code>market_identifier</code> and <code>product_identifier</code> together uniquely identify an observation, which is used by the function <code>update_BLP_data</code> to update any variable in the data (in this case <code>product_identifier</code> is mandatory).</p>
<p>In the cereal example, this gives the following dataframe:</p>
<pre><code class="language-r">head(productData_cereal)
#&gt;        price const sugar mushy       share     cdid        IV1        IV2
#&gt; 1 0.07208794     1     2     1 0.012417212 market_1 -0.2159728 0.04057341
#&gt; 2 0.11417849     1    18     1 0.007809387 market_1 -0.2452393 0.05474226
#&gt; 3 0.13239066     1     4     1 0.012994511 market_1 -0.1764587 0.04659597
#&gt; 4 0.13034408     1     3     0 0.005769961 market_1 -0.1214013 0.04876037
#&gt; 5 0.15482331     1    12     0 0.017934141 market_1 -0.1326114 0.03962835
#&gt; 6 0.13704921     1    14     0 0.026601892 market_1 -0.1534998 0.04298842
#&gt;          IV3          IV4         IV5           IV6        IV7         IV8
#&gt; 1  -3.247948 -0.523937695 -0.23246005  0.0068326605  3.1397395 -0.57478633
#&gt; 2 -19.832461 -0.180519694  0.01468859  0.0007988026  0.2876539  0.03293960
#&gt; 3  -2.878531 -0.284219004 -0.21553691 -0.0318693281  2.8862741 -0.74976495
#&gt; 4  -2.059918 -0.328412257 -0.22206995 -0.0314740402  4.4531096  0.25567529
#&gt; 5  -6.137598 -0.138625095 -0.18936521 -0.0437471023 -3.5546508  0.13882114
#&gt; 6  -8.417332  0.007829087 -0.13850121 -0.0210582272 -2.7594799  0.05020052
#&gt;          IV9       IV10       IV11        IV12          IV13       IV14
#&gt; 1  0.2062202  0.1774656  2.1163580 -0.15470824 -0.0057964065 0.01453802
#&gt; 2  0.1051208 -0.2875618 -7.3740909 -0.57641176  0.0129908544 0.07614324
#&gt; 3 -0.4789565  0.2147389  2.1878721 -0.20734643  0.0035092777 0.09178117
#&gt; 4 -0.4729673  0.3560980  2.7045762  0.04074801 -0.0037242656 0.09473168
#&gt; 5 -0.6886784  0.2602726  1.2612419  0.03483558 -0.0005676374 0.10245147
#&gt; 6 -0.2734440  0.1273060  0.3375543  0.02351037  0.0002637777 0.08627983
#&gt;         IV15       IV16       IV17       IV18       IV19       IV20 product_id
#&gt; 1 0.12624398 0.06734464 0.06842261 0.03480046 0.12634612 0.03548368   cereal_1
#&gt; 2 0.02973565 0.08786672 0.11050060 0.08778380 0.04987192 0.07257905   cereal_2
#&gt; 3 0.16377308 0.11188073 0.10822551 0.08643905 0.12234707 0.10184248   cereal_3
#&gt; 4 0.13527378 0.08809001 0.10176745 0.10177748 0.11074119 0.10433204   cereal_4
#&gt; 5 0.13063951 0.08481820 0.10107461 0.12516923 0.13346381 0.12111110   cereal_5
#&gt; 6 0.07233581 0.02225051 0.10564387 0.11603699 0.09965063 0.10572660   cereal_6
#&gt;   productdummy
#&gt; 1     product1
#&gt; 2     product2
#&gt; 3     product3
#&gt; 4     product4
#&gt; 5     product5
#&gt; 6     product6
</code></pre>
<h2>Integration Draws</h2>
<p>The arguments related to the numerical integration problem are of particular importance when providing
own integration draws and weights, which is most relevant for observed heterogeneity
(for unobserved heterogeneity, the straightforward approach is the use of automatic integration).</p>
<p>In the cereal data, both, observed and unobserved heterogeneity, is used for the random coefficients.
Starting with observed heterogeneity, user provided draws are collected in a list. Each list entry must be
named according to the name of a demographic. Each entry contains the following variables:</p>
<ul>
<li>a variable <code>market_identifier</code> that matches each line to a market (same variable name as in <code>productData</code>)</li>
<li>integration draws for each market</li>
</ul>
<p>In the cereal example, observed heterogeneity is provided as follows (list names correspond to the demographics):</p>
<pre><code class="language-r">demographicData_cereal$income[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2     draw_3      draw_4
#&gt; 1 market_1 0.49512349  0.3787622  0.1050146 -1.48548093
#&gt; 2 market_2 0.05389113 -1.5030833  0.6217917  0.26922901
#&gt; 3 market_3 0.62459788 -0.2242698 -0.2846169  0.67845943
#&gt; 4 market_4 0.94419851  0.4056359  0.5859923  0.01813051

demographicData_cereal$incomesq[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2    draw_3      draw_4
#&gt; 1 market_1  8.3313042   6.121865  1.030803 -25.5836047
#&gt; 2 market_2  0.0966346 -25.849845 10.767233   4.0668173
#&gt; 3 market_3 10.8215619  -4.894545 -5.956954  11.8673879
#&gt; 4 market_4 17.1121550   6.629730 10.075529  -0.5537043

demographicData_cereal$age[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2       draw_3     draw_4
#&gt; 1 market_1 -0.2301090 -2.5326941 -0.006965458 -0.8279460
#&gt; 2 market_2  0.1414545 -0.1813188 -1.279931134 -0.4532526
#&gt; 3 market_3 -0.1813188 -0.5867840  0.208145922 -0.4532526
#&gt; 4 market_4  0.7444506  0.1414545  0.645359728  0.8346017

demographicData_cereal$child[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2     draw_3     draw_4
#&gt; 1 market_1 -0.2308511  0.7691489 -0.2308511  0.7691489
#&gt; 2 market_2 -0.2308511 -0.2308511  0.7691489 -0.2308511
#&gt; 3 market_3 -0.2308511  0.7691489 -0.2308511 -0.2308511
#&gt; 4 market_4 -0.2308511 -0.2308511 -0.2308511 -0.2308511
</code></pre>
<p>If demographic input (<code>demographicData</code>) is missing, the estimation routine considers only coefficients for unobserved heterogeneity. This can be done by already implemented integration methods via <code>integration_method</code> as shown in the estimation section. In Nevo’s cereal example however, a specific set of 20 draws is
given. For this situation, draws are also provided as a list (list names correspond to the formula’s random coefficients and each list entry has a variable <code>market_identifier</code>):</p>
<pre><code class="language-r">originalDraws_cereal$constant[1:4, 1:5]
#&gt;       cdid       draw_1     draw_2     draw_3      draw_4
#&gt; 1 market_1  0.434100553 -0.7266491 -0.6230607 -0.04131699
#&gt; 2 market_2  0.001702598  0.2228245 -1.0287201  0.38312476
#&gt; 3 market_3 -0.529569305  0.7248712  0.2910167 -1.39164253
#&gt; 4 market_4  0.019233489 -1.4250308 -0.2678170 -2.26541236

# renaming constants:
names(originalDraws_cereal)[1] &lt;- &quot;(Intercept)&quot;

originalDraws_cereal$price[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2     draw_3     draw_4
#&gt; 1 market_1 -1.5008378  0.1331817 -0.1382405  1.2571357
#&gt; 2 market_2  0.0276477 -0.8414414 -0.9056861 -2.0306179
#&gt; 3 market_3 -0.4768085 -0.9348689  1.4300456  2.6188581
#&gt; 4 market_4  0.5396019  0.1698178  0.7128376 -0.1216309

originalDraws_cereal$sugar[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2     draw_3     draw_4
#&gt; 1 market_1 -1.1510786 -0.5007498  0.7974412 -0.6830540
#&gt; 2 market_2  1.0451218  1.0170277  2.3012550  0.1490338
#&gt; 3 market_3 -1.0187809  0.3107185 -0.9531532  0.8057080
#&gt; 4 market_4 -0.5760582 -0.5072059 -0.7496653  1.1163544

originalDraws_cereal$mushy[1:4, 1:5]
#&gt;       cdid     draw_1     draw_2      draw_3     draw_4
#&gt; 1 market_1 0.16101681  0.1297316 -0.79554915  0.2590437
#&gt; 2 market_2 0.23595798  0.1345995  0.07284586  0.9509871
#&gt; 3 market_3 0.02922435 -0.1704289  0.36395246  0.4879702
#&gt; 4 market_4 1.27701102  0.4284194  0.46124654 -1.0110437
</code></pre>
<p>As demonstrated above, list entries for draws of constants <strong>must</strong> be named <code>(Intercept)</code>. Other names of list entries must match the random coefficients specified in the formula.</p>
<h2>Calling BLP_data</h2>
<p>Calling <code>BLP_data</code> structures and prepares the data for estimation and creates the data object:</p>
<pre><code class="language-r">productData_cereal$startingGuessesDelta &lt;- c(log(w_guesses_cereal)) # include orig. draws in the product data

cereal_data &lt;- BLP_data(
  model = nevos_model,
  market_identifier = &quot;cdid&quot;,
  par_delta = &quot;startingGuessesDelta&quot;,
  product_identifier = &quot;product_id&quot;,
  productData = productData_cereal,
  demographic_draws = demographicData_cereal,
  blp_inner_tol = 1e-6, blp_inner_maxit = 5000,
  integration_draws = originalDraws_cereal,
  integration_weights = rep(1 / 20, 20)
)
</code></pre>
<p>The arguments in greater detail:</p>
<ul>
<li>
<p><code>model</code> provides the utility model as explained above</p>
</li>
<li>
<p><code>market_identifier</code> gives the name of the variable in <code>productData</code> that matches
each observation to a market</p>
</li>
<li>
<p><code>product_identifier</code> gives the name of the variable in <code>productData</code> that matches
each observation to a product (must be unique in a market)</p>
</li>
<li>
<p><code>productData</code> is given as a dataframe and <code>demographicData</code> as a list as described above</p>
</li>
<li>
<p><code>par_delta</code> gives the name of the variable in <code>productData</code> for mean utilities</p>
</li>
<li>
<p><code>blp_inner_tol</code> , <code>blp_inner_maxit</code>: arguments related to be BLP algorithm include the convergence threshold and the maximum number of iterations in the contraction mapping</p>
</li>
<li>
<p>if integration draws are provided manually, <code>integration_draws</code> and
<code>integration_weights</code> need to be specified</p>
</li>
<li>
<p>for automatic integration the user specifies <code>integration_method</code>, for example
<code>integration_method= &quot;MLHS&quot;</code>, and the accuracy of the integration method by
<code>integration_accuracy</code> (for stochastic integration methods this equals the number
of draws)</p>
</li>
</ul>
<p>If you decide to update your data later, you can use the function <code>update_BLP_data</code>.</p>
<h1>Estimation</h1>
<h2>Starting guesses</h2>
<p>The provided set of starting guesses <code>par_theta2</code> is matched with formula input and demographic data:</p>
<ul>
<li>rownames of <code>par_theta2</code> must match with the random coefficients specified in the formula (note: constants <strong>must</strong> be named <code>(Intercept)</code> )</li>
<li>colnames of <code>par_theta2</code> must match with list entry names of <code>demographicData</code> and a column for unobserved heterogeneity (<strong>must</strong> be named `unobs_sd)</li>
<li><code>NA</code>s in <code>par_theta2</code> indicate the exclusion from estimation, i.e. the coefficient is assumed to be zero.</li>
</ul>
<p>These requirements are demonstrated with a set of exemplary starting guesses:</p>
<pre><code class="language-r"># before:
theta_guesses_cereal
#&gt;        [,1]    [,2] [,3]    [,4]   [,5]
#&gt; [1,] 0.3302  5.4819  0.0  0.2037 0.0000
#&gt; [2,] 2.4526 15.8935 -1.2  0.0000 2.6342
#&gt; [3,] 0.0163 -0.2506  0.0  0.0511 0.0000
#&gt; [4,] 0.2441  1.2650  0.0 -0.8091 0.0000
theta_guesses_cereal[theta_guesses_cereal == 0] &lt;- NA
colnames(theta_guesses_cereal) &lt;- c(&quot;unobs_sd&quot;, &quot;income&quot;, &quot;incomesq&quot;, &quot;age&quot;, &quot;child&quot;)
rownames(theta_guesses_cereal) &lt;- c(&quot;(Intercept)&quot;, &quot;price&quot;, &quot;sugar&quot;, &quot;mushy&quot;)

# correctly named:
theta_guesses_cereal
#&gt;             unobs_sd  income incomesq     age  child
#&gt; (Intercept)   0.3302  5.4819       NA  0.2037     NA
#&gt; price         2.4526 15.8935     -1.2      NA 2.6342
#&gt; sugar         0.0163 -0.2506       NA  0.0511     NA
#&gt; mushy         0.2441  1.2650       NA -0.8091     NA
</code></pre>
<h2>Calling estimateBLP</h2>
<p>The following code performs the demand estimation:</p>
<pre><code class="language-r">cereal_est &lt;- estimateBLP(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  solver_method = &quot;BFGS&quot;, solver_maxit = 1000, solver_reltol = 1e-6,
  standardError = &quot;heteroskedastic&quot;,
  extremumCheck = FALSE,
  printLevel = 1
)
#&gt; blp_data were prepared with the following arguments:
#&gt; BLP_data(model = nevos_model, market_identifier = &quot;cdid&quot;, product_identifier = &quot;product_id&quot;, 
#&gt;     par_delta = &quot;startingGuessesDelta&quot;, productData = productData_cereal, 
#&gt;     demographic_draws = demographicData_cereal, integration_draws = originalDraws_cereal, 
#&gt;     integration_weights = rep(1/20, 20), blp_inner_tol = 1e-06, 
#&gt;     blp_inner_maxit = 5000)
#&gt; Starting a BLP demand estimation with  2256  observations in  94  markets...
#&gt; [integration::method  integration::amountDraws 20 ]
#&gt; [blp::inner_tol 1e-06  blp::inner_maxit 5000 ]
#&gt; [solver::method BFGS  solver::maxit 1000  solver::reltol 1e-06 ]
#&gt; gmm objective: 29.3522
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: 22451.18
#&gt; gmm objective: 775.9515
#&gt; gmm objective: 71.6209
#&gt; gmm objective: 26.8851
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: 330914
#&gt; gmm objective: 12694.84
#&gt; gmm objective: 311.8842
#&gt; gmm objective: 38.2627
#&gt; gmm objective: 26.9935
#&gt; gmm objective: 26.8196
#&gt; gmm objective: 40772.63
#&gt; gmm objective: 1186.144
#&gt; gmm objective: 103.4133
#&gt; gmm objective: 27.9556
#&gt; gmm objective: 26.1524
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: 28234.6
#&gt; gmm objective: 756.8709
#&gt; gmm objective: 37.7704
#&gt; gmm objective: 24.7211
#&gt; gmm objective: 5772.739
#&gt; gmm objective: 202.5456
#&gt; gmm objective: 27.2616
#&gt; gmm objective: 23.9898
#&gt; gmm objective: 838.469
#&gt; gmm objective: 32.1783
#&gt; gmm objective: 21.9662
#&gt; gmm objective: 23912.56
#&gt; gmm objective: 244.3514
#&gt; gmm objective: 20.9664
#&gt; gmm objective: 1417.216
#&gt; gmm objective: 56.3625
#&gt; gmm objective: 21.2928
#&gt; gmm objective: 20.6459
#&gt; gmm objective: 24.7031
#&gt; gmm objective: 19.3915
#&gt; gmm objective: 192.3949
#&gt; gmm objective: 18.8625
#&gt; gmm objective: 20.5334
#&gt; gmm objective: 17.7234
#&gt; gmm objective: 16.7846
#&gt; gmm objective: 16.4664
#&gt; gmm objective: 15.9588
#&gt; gmm objective: 15.0231
#&gt; gmm objective: 14.9101
#&gt; gmm objective: 14.8987
#&gt; gmm objective: 14.8961
#&gt; gmm objective: 14.8902
#&gt; gmm objective: 14.8788
#&gt; gmm objective: 14.8479
#&gt; gmm objective: 14.7731
#&gt; gmm objective: 14.5807
#&gt; gmm objective: 14.0873
#&gt; gmm objective: 12.8012
#&gt; gmm objective: 11.9828
#&gt; gmm objective: 9.4672
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: 150504.2
#&gt; gmm objective: 6437.658
#&gt; gmm objective: 224.7393
#&gt; gmm objective: 13.0643
#&gt; gmm objective: 9.2023
#&gt; gmm objective: Inf [delta contains NaN's] 
#&gt; gmm objective: 10140.17
#&gt; gmm objective: 554.5767
#&gt; gmm objective: 34.6091
#&gt; gmm objective: 10.0322
#&gt; gmm objective: 9.1844
#&gt; gmm objective: 75730.14
#&gt; gmm objective: 2145.751
#&gt; gmm objective: 45.6103
#&gt; gmm objective: 9.9089
#&gt; gmm objective: 9.0889
#&gt; gmm objective: 111102.8
#&gt; gmm objective: 15512.82
#&gt; gmm objective: 389.1241
#&gt; gmm objective: 20.1367
#&gt; gmm objective: 8.7624
#&gt; gmm objective: 766.0638
#&gt; gmm objective: 49.5382
#&gt; gmm objective: 10.0242
#&gt; gmm objective: 8.6598
#&gt; gmm objective: 155.1232
#&gt; gmm objective: 12.3475
#&gt; gmm objective: 8.5964
#&gt; gmm objective: 308.36
#&gt; gmm objective: 10.1499
#&gt; gmm objective: 8.3448
#&gt; gmm objective: 1593.047
#&gt; gmm objective: 18.5902
#&gt; gmm objective: 7.9521
#&gt; gmm objective: 24.6953
#&gt; gmm objective: 7.4967
#&gt; gmm objective: 7.8465
#&gt; gmm objective: 7.4219
#&gt; gmm objective: 7.3411
#&gt; gmm objective: 7.2325
#&gt; gmm objective: 7.0497
#&gt; gmm objective: 6.9818
#&gt; gmm objective: 6.9711
#&gt; gmm objective: 6.9695
#&gt; gmm objective: 6.9696
#&gt; gmm objective: 6.9692
#&gt; gmm objective: 6.9633
#&gt; gmm objective: 6.9462
#&gt; gmm objective: 6.8986
#&gt; gmm objective: 6.8301
#&gt; gmm objective: 6.6517
#&gt; gmm objective: 6.3046
#&gt; gmm objective: 5.7187
#&gt; gmm objective: 5.0274
#&gt; gmm objective: 4.6491
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 54557.62
#&gt; gmm objective: 2335.286
#&gt; gmm objective: 90.1735
#&gt; gmm objective: 7.3992
#&gt; gmm objective: 4.667
#&gt; gmm objective: 4.576
#&gt; gmm objective: 4.575
#&gt; gmm objective: 14656.41
#&gt; gmm objective: 601.8347
#&gt; gmm objective: 32.5354
#&gt; gmm objective: 5.863
#&gt; gmm objective: 4.6245
#&gt; gmm objective: 4.5771
#&gt; gmm objective: 4.5758
#&gt; gmm objective: 4.5759
#&gt; gmm objective: 4.5757
#&gt; gmm objective: 4.5755
#&gt; gmm objective: 4.5754
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 16969.25
#&gt; gmm objective: 603.3224
#&gt; gmm objective: 23.8438
#&gt; gmm objective: 5.2753
#&gt; gmm objective: 4.5966
#&gt; gmm objective: 4.575
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5753
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; gmm objective: 4.5752
#&gt; ------------------------------------------ 
#&gt; Solver message: Successful convergence 
#&gt; ------------------------------------------ 
#&gt; Final GMM evaluation at optimal parameters: 
#&gt; gmm objective: 4.5744
#&gt; 	 theta (RC): 0.55 3.29 -0.01 0.09 
#&gt; 	 theta (demogr.): 2.3 577.44 -0.38 0.83 0 -29.63 0 0 1.27 0 0.05 -1.35 0 11.03 0 0 
#&gt; 	 inner iterations: 70 
#&gt; 	 gradient: -0.0605 0.0017 -0.162 -0.0354 -0.0926 -0.0083 -2.2061 0.2945 -0.1468 0.0797 -1.2189 0.2315 2e-04 
#&gt; Using the heteroskedastic asymptotic variance-covariance matrix...

summary(cereal_est)
#&gt; 
#&gt; Data information:
#&gt; 
#&gt; 	 94 market(s) with 2256 products 
#&gt; 	 25 linear coefficient(s) (24 exogenous coefficients) 
#&gt; 	 13 non-linear parameters related to random coefficients 
#&gt; 	 4 demographic variable(s) 
#&gt; 
#&gt; Estimation results:
#&gt; 
#&gt;  Linear Coefficients
#&gt;                          Estimate Std. Error   t value     Pr(&gt;|t|)
#&gt; (Intercept)            -2.5769264  0.8531569 -3.020460 2.523909e-03
#&gt; price                 -62.1403349 14.5135858 -4.281529 1.856137e-05
#&gt; productdummyproduct10   1.9000897  0.6653478  2.855784 4.293071e-03
#&gt; productdummyproduct11   3.6767952  0.6664428  5.517045 3.447468e-08
#&gt; productdummyproduct12   0.2615994  0.2287542  1.143583 2.527967e-01
#&gt; productdummyproduct13   2.3591835  0.2184213 10.801071 3.402135e-27
#&gt; productdummyproduct14   3.8446786  0.6855662  5.608034 2.046376e-08
#&gt; productdummyproduct15   4.2873240  0.6779154  6.324276 2.544228e-10
#&gt; productdummyproduct16   6.0916947  0.6723137  9.060792 1.295068e-19
#&gt; productdummyproduct17   2.6036321  0.6510521  3.999115 6.357976e-05
#&gt; productdummyproduct18   1.4324858  0.6079004  2.356448 1.845065e-02
#&gt; productdummyproduct19   4.3135147  0.6191372  6.966977 3.238237e-12
#&gt; productdummyproduct2    4.8750516  0.6334282  7.696297 1.400664e-14
#&gt; productdummyproduct20   4.1706989  0.6075700  6.864557 6.669789e-12
#&gt; productdummyproduct21   4.9106550  0.6827987  7.191951 6.387201e-13
#&gt; productdummyproduct22   1.7215961  0.5917418  2.909370 3.621574e-03
#&gt; productdummyproduct23   3.2960677  0.6839398  4.819237 1.441085e-06
#&gt; productdummyproduct24   1.8879979  0.7307294  2.583717 9.774201e-03
#&gt; productdummyproduct3    2.3028803  0.2314068  9.951652 2.480314e-23
#&gt; productdummyproduct4    1.3668373  0.5940217  2.300989 2.139225e-02
#&gt; 
#&gt; ...
#&gt; 
#&gt;  5 estimates are omitted. They are available in the LinCoefficients generated by summary.
#&gt; 
#&gt;  Random Coefficients
#&gt;                           Estimate   Std. Error    t value     Pr(&gt;|t|)
#&gt; unobs_sd*(Intercept)   0.551339802   0.16015070  3.4426313 0.0005760842
#&gt; unobs_sd*price         3.285559242   1.30636137  2.5150462 0.0119016777
#&gt; unobs_sd*sugar        -0.005237547   0.01336128 -0.3919943 0.6950624586
#&gt; unobs_sd*mushy         0.091406886   0.18480221  0.4946201 0.6208683098
#&gt; income*(Intercept)     2.303677740   1.19131427  1.9337280 0.0531465813
#&gt; income*price         577.439894302 264.92313009  2.1796507 0.0292833612
#&gt; income*sugar          -0.384035468   0.11965304 -3.2095755 0.0013293115
#&gt; income*mushy           0.826450260   0.77955169  1.0601609 0.2890713857
#&gt; incomesq*price       -29.627526212  13.80993186 -2.1453782 0.0319226238
#&gt; age*(Intercept)        1.268858974   0.62894244  2.0174485 0.0436487314
#&gt; age*sugar              0.051714014   0.02546546  2.0307513 0.0422802274
#&gt; age*mushy             -1.350839887   0.66343728 -2.0361230 0.0417380079
#&gt; child*price           11.025866509   4.11565257  2.6790081 0.0073840611
#&gt; 
#&gt;  Wald Test
#&gt; 126.7789 on  13 DF, p-value: 9.13936371295069e-21 
#&gt; 
#&gt; Computational Details: 
#&gt; 	 Solver converged with 172 iterations to a minimum at 4.5744 .
#&gt; 	 Local minima check: NA
#&gt; 	 stopping criterion outer loop: 1e-06
#&gt; 	 stopping criterion inner loop: 1e-06
#&gt; 	 Market shares are integrated with provided_by_user and 20 draws. 
#&gt; 	 Method for standard errors: heteroskedastic
</code></pre>
<p>The arguments in greater detail:</p>
<ul>
<li>
<p><code>par_theta2</code> gives initial values for non-linear parameters to be optimized
over. Correct naming of columns and rows is important to allow correct matching.</p>
</li>
<li>
<p><code>solver_method</code>, <code>solver_maxit</code> , <code>solver_reltol</code>: solver related arguments that specify the R internal optimization (<code>optim</code> function). Additional arguments can be passed to optim via <code>...</code></p>
</li>
<li>
<p><code>standardError</code> can be specified as <code>homoskedastic</code>, <code>heteroskedastic</code> or
<code>cluster</code>. The latter requires the variable <code>group_structure</code> in <code>productData</code> giving the related
cluster.</p>
</li>
<li>
<p>if <code>extremumCheck</code> is <code>TRUE</code>, numerical derivatives at the solver optimum are used
to check, if a local minimum was found</p>
</li>
<li>
<p><code>printLevel</code> controls for the amount of information that is provided during the
estimation</p>
</li>
</ul>
<p>Many of these arguments have default values. In the following setting you see a
minimum of necessary arguments with an automatic generation of integration
draws and just unobserved heterogeneity. The summary output informs you about the most important default values.</p>
<pre><code class="language-r">cereal_data2 &lt;- BLP_data(
  model = nevos_model,
  market_identifier = &quot;cdid&quot;,

  product_identifier = &quot;product_id&quot;,
  productData = productData_cereal,
  integration_method = &quot;MLHS&quot;,
  integration_accuracy = 20, integration_seed = 213
)
#&gt; Mean utility (variable name: `delta`) is initialized with 0 because of missing or invalid par_delta argument.

cereal_est2 &lt;- estimateBLP(blp_data = cereal_data2, printLevel = 1)
#&gt; blp_data were prepared with the following arguments:
#&gt; BLP_data(model = nevos_model, market_identifier = &quot;cdid&quot;, product_identifier = &quot;product_id&quot;, 
#&gt;     productData = productData_cereal, integration_accuracy = 20, 
#&gt;     integration_method = &quot;MLHS&quot;, integration_seed = 213)
#&gt; Starting a BLP demand estimation with  2256  observations in  94  markets...
#&gt; [integration::method  integration::amountDraws 20 ]
#&gt; [blp::inner_tol 1e-09  blp::inner_maxit 10000 ]
#&gt; [solver::method BFGS  solver::maxit 10000  solver::reltol 1e-06 ]
#&gt; gmm objective: 189.9432
#&gt; gmm objective: 5632.612
#&gt; gmm objective: 439.3216
#&gt; gmm objective: 202.5585
#&gt; gmm objective: 190.4644
#&gt; gmm objective: 189.9569
#&gt; gmm objective: 189.9422
#&gt; gmm objective: 366.2611
#&gt; gmm objective: 196.3801
#&gt; gmm objective: 190.0315
#&gt; gmm objective: 189.9122
#&gt; gmm objective: 240.4055
#&gt; gmm objective: 191.6947
#&gt; gmm objective: 189.9326
#&gt; gmm objective: 189.903
#&gt; gmm objective: 189.8537
#&gt; gmm objective: 189.8352
#&gt; gmm objective: 189.8352
#&gt; gmm objective: 212.3727
#&gt; gmm objective: 190.7591
#&gt; gmm objective: 189.8716
#&gt; gmm objective: 189.8367
#&gt; gmm objective: 189.8353
#&gt; gmm objective: 189.8352
#&gt; gmm objective: 189.8352
#&gt; ------------------------------------------ 
#&gt; Solver message: Successful convergence 
#&gt; ------------------------------------------ 
#&gt; Final GMM evaluation at optimal parameters: 
#&gt; gmm objective: 189.8352
#&gt; 	 theta (RC): 0 -0.32 0 0.06 
#&gt; 	 theta (demogr.):  
#&gt; 	 inner iterations: 61 
#&gt; 	 gradient: 0 0 0.0316 0 
#&gt; Using the heteroskedastic asymptotic variance-covariance matrix...

summary(cereal_est2)
#&gt; 
#&gt; Data information:
#&gt; 
#&gt; 	 94 market(s) with 2256 products 
#&gt; 	 25 linear coefficient(s) (24 exogenous coefficients) 
#&gt; 	 4 non-linear parameters related to random coefficients 
#&gt; 	 0 demographic variable(s) 
#&gt; 
#&gt; Estimation results:
#&gt; 
#&gt;  Linear Coefficients
#&gt;                          Estimate Std. Error    t value      Pr(&gt;|t|)
#&gt; (Intercept)            -1.7731873  0.1602903 -11.062350  1.910261e-28
#&gt; price                 -30.1150257  1.2899147 -23.346526 1.494838e-120
#&gt; productdummyproduct10   1.8588694  0.1680453  11.061715  1.923839e-28
#&gt; productdummyproduct11   1.7623940  0.1495181  11.787162  4.546047e-32
#&gt; productdummyproduct12  -0.2874741  0.1592495  -1.805180  7.104647e-02
#&gt; productdummyproduct13   2.2500443  0.1511584  14.885338  4.104043e-50
#&gt; productdummyproduct14   1.7795210  0.1626780  10.938918  7.509066e-28
#&gt; productdummyproduct15   2.1598572  0.1600857  13.491879  1.745928e-41
#&gt; productdummyproduct16   3.6903310  0.1718044  21.479845 2.403069e-102
#&gt; productdummyproduct17   0.7890090  0.1696815   4.649940  3.320313e-06
#&gt; productdummyproduct18   0.8752804  0.1637558   5.345035  9.039982e-08
#&gt; productdummyproduct19   1.7678372  0.1493846  11.834129  2.600273e-32
#&gt; productdummyproduct2    2.3665019  0.1535953  15.407387  1.459966e-53
#&gt; productdummyproduct20   2.8086743  0.1635328  17.174992  4.087069e-66
#&gt; productdummyproduct21   2.6809487  0.1689161  15.871478  9.986136e-57
#&gt; productdummyproduct22   0.4722649  0.1546958   3.052862  2.266698e-03
#&gt; productdummyproduct23   1.3755276  0.1541332   8.924278  4.486152e-19
#&gt; productdummyproduct24   2.1728901  0.1699102  12.788464  1.901958e-37
#&gt; productdummyproduct3    1.8016223  0.1488931  12.100102  1.054799e-33
#&gt; productdummyproduct4    0.7639859  0.1468578   5.202216  1.969266e-07
#&gt; 
#&gt; ...
#&gt; 
#&gt;  5 estimates are omitted. They are available in the LinCoefficients generated by summary.
#&gt; 
#&gt;  Random Coefficients
#&gt;                           Estimate Std. Error      t value  Pr(&gt;|t|)
#&gt; unobs_sd*(Intercept) -0.0028937363  1.1219334 -0.002579241 0.9979421
#&gt; unobs_sd*price       -0.3179154684  9.1643440 -0.034690478 0.9723266
#&gt; unobs_sd*sugar       -0.0003841069  0.1139372 -0.003371217 0.9973102
#&gt; unobs_sd*mushy        0.0603775693  2.2758039  0.026530216 0.9788344
#&gt; 
#&gt;  Wald Test
#&gt; 0.0018 on  4 DF, p-value: 0.9999995836557 
#&gt; 
#&gt; Computational Details: 
#&gt; 	 Solver converged with 25 iterations to a minimum at 189.8352 .
#&gt; 	 Local minima check: NA
#&gt; 	 stopping criterion outer loop: 1e-06
#&gt; 	 stopping criterion inner loop: 1e-09
#&gt; 	 Market shares are integrated with MLHS and 20 draws. 
#&gt; 	 Method for standard errors: heteroskedastic
</code></pre>
<h1>Postestimation</h1>
<h2>Standard Errors</h2>
<p>Standard errors can be computed with three options that control for the unobserved characteristic \(\xi\), which consists of \(N\) elements. \(\Omega\) denotes the variance covariance matrix of \(\xi\).</p>
<ul>
<li>
<p>option <code>homoskedastic</code> requires the standard deviation \(\sigma_i\) for each $\xi_i ;\forall
i\in 1,\cdots,N$ to be identical:
$$\Omega = \begin{pmatrix} \sigma &amp; 0 &amp; \dots &amp; 0\\ 0 &amp; \sigma &amp;  &amp; 0\\ \vdots &amp;  &amp; \ddots &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \sigma \\ \end{pmatrix}$$</p>
</li>
<li>
<p>option <code>heteroskedastic</code> allows for individual standard deviations \(\sigma_i\) for each
\(\xi_i\) :
$$\Omega = \begin{pmatrix} \sigma_1 &amp; 0 &amp; \dots &amp; 0\\ 0 &amp; \sigma_2 &amp;  &amp; 0\\ \vdots &amp;  &amp; \ddots &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \sigma_N \\ \end{pmatrix}$$</p>
</li>
<li>
<p>option <code>cluster</code> allows for cluster individual variance covariance matrices in each of \(M\) cluster groups. For this option the argument <code>group_structure</code> needs to be specified in the function <code>BLP_data</code> to determine the cluster group. This gives the block-diagonal form with \(\Sigma_m\) as the variance covariance matrix for all \(\xi_i\) in cluster \(m\):</p>
</li>
</ul>
<p>$$\Omega = \begin{pmatrix} \Sigma_1 &amp; 0 &amp; \dots &amp; 0\\ 0 &amp; \Sigma_2 &amp;  &amp; 0\\ \vdots &amp;  &amp; \ddots &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; \Sigma_M \\ \end{pmatrix}$$</p>
<h2>Elasticities</h2>
<p>The following code demonstrates the calculation of elasticities for the estimation object <code>cereal_est</code>.</p>
<pre><code class="language-r"># extract parameters from output
theta1_price &lt;- cereal_est$theta_lin[&quot;price&quot;, ]
theta2 &lt;- matrix(NA, nrow = 4, ncol = 5)
colnames(theta2) &lt;- c(&quot;unobs_sd&quot;, &quot;income&quot;, &quot;incomesq&quot;, &quot;age&quot;, &quot;child&quot;)
rownames(theta2) &lt;- c(&quot;(Intercept)&quot;, &quot;price&quot;, &quot;sugar&quot;, &quot;mushy&quot;)
for (i in 1:13) {
  theta2[cereal_est$indices[i, 1], cereal_est$indices[i, 2]] &lt;- cereal_est$theta_rc[i]
}

delta_data &lt;- data.frame(
  &quot;product_id&quot; = cereal_data$parameters$product_id,
  &quot;cdid&quot; = cereal_data$parameters$market_id_char_in,
  &quot;startingGuessesDelta&quot; = cereal_est$delta
)
# always use update_BLP_data() to update data object to maintain consistent data
cereal_data &lt;- update_BLP_data(
  data_update = delta_data,
  blp_data = cereal_data
)
#&gt; Mean utility variable startingGuessesDelta has been updated.

shareObj &lt;- getShareInfo(
  blp_data = cereal_data,
  par_theta2 = theta2,
  printLevel = 1
)
#&gt; Mean utility (delta) is used as provided in the BLP_data() function.

get_elasticities(
  blp_data = cereal_data,
  share_info = shareObj,
  theta_lin = theta1_price,
  variable = &quot;price&quot;,
  products = c(&quot;cereal_1&quot;, &quot;cereal_4&quot;),
  market = &quot;market_2&quot;
)
#&gt;              cereal_1     cereal_4
#&gt; cereal_1 -1.710300060  0.005433147
#&gt; cereal_4  0.006965292 -2.717589277
</code></pre>
<p>The value of the elasticity matrix in row \(j\) and column \(i\) for a variable \(x\), gives the effect of a change in product \(i\)’s characteristic \(x\) on the share of product \(j\).</p>
<h1>Modular Examples</h1>
<p>Further analysis like incorporating a supply side or performing a merger simulation often requires access to building blocks of the BLP algorithm. The following wrappers insure correct data inputs and access the internal functions of the algorithm.</p>
<p>In the following, you find an example of the contraction mapping and an evaluation of the GMM function at the starting guess:</p>
<pre><code class="language-r">delta_eval &lt;- getDelta_wrap(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  printLevel = 4
)
#&gt; ----------------------
#&gt; 	 dist: 0.230998
#&gt; 	 dist: 0.188133
#&gt; 	 dist: 0.161181
#&gt; 	 dist: 0.133303
#&gt; 	 dist: 0.107161
#&gt; 	 dist: 0.0844808
#&gt; 	 dist: 0.0657196
#&gt; 	 dist: 0.0506556
#&gt; 	 dist: 0.0387915
#&gt; 	 dist: 0.0295683
#&gt; 	 dist: 0.0224622
#&gt; 	 dist: 0.0170219
#&gt; 	 dist: 0.0128758
#&gt; 	 dist: 0.00972657
#&gt; 	 dist: 0.00734024
#&gt; 	 dist: 0.00553524
#&gt; 	 dist: 0.00417178
#&gt; 	 dist: 0.00314286
#&gt; 	 dist: 0.00236698
#&gt; 	 dist: 0.00178222
#&gt; 	 dist: 0.00134169
#&gt; 	 dist: 0.00100991
#&gt; 	 dist: 0.000760105
#&gt; 	 dist: 0.000572046
#&gt; 	 dist: 0.000430491
#&gt; 	 dist: 0.00032395
#&gt; 	 dist: 0.000243769
#&gt; 	 dist: 0.00019173
#&gt; 	 dist: 0.000156244
#&gt; 	 dist: 0.000127321
#&gt; 	 dist: 0.000103748
#&gt; 	 dist: 8.45372e-05
#&gt; 	 dist: 6.88821e-05
#&gt; 	 dist: 5.61251e-05
#&gt; 	 dist: 4.573e-05
#&gt; 	 dist: 3.72598e-05
#&gt; 	 dist: 3.03582e-05
#&gt; 	 dist: 2.47347e-05
#&gt; 	 dist: 2.01528e-05
#&gt; 	 dist: 1.64195e-05
#&gt; 	 dist: 1.33778e-05
#&gt; 	 dist: 1.08995e-05
#&gt; 	 dist: 8.88033e-06
#&gt; 	 dist: 7.23518e-06
#&gt; 	 dist: 5.8948e-06
#&gt; 	 dist: 4.80272e-06
#&gt; 	 dist: 3.91296e-06
#&gt; 	 dist: 3.18804e-06
#&gt; 	 dist: 2.59741e-06
#&gt; 	 dist: 2.14713e-06
#&gt; 	 dist: 1.78121e-06
#&gt; 	 dist: 1.47765e-06
#&gt; 	 dist: 1.22582e-06
#&gt; 	 dist: 1.01691e-06
#&gt; 	 dist: 9.93231e-07

productData_cereal$startingGuessesDelta[1:6]
#&gt; [1] -3.944367 -2.845205 -3.958199 -4.934153 -2.425356 -4.086816
delta_eval$delta[1:6]
#&gt; cereal_1_market_1 cereal_2_market_1 cereal_3_market_1 cereal_4_market_1 
#&gt;         -7.069801         -4.357675         -6.056909         -5.887501 
#&gt; cereal_5_market_1 cereal_6_market_1 
#&gt;         -3.501289         -3.079323
delta_eval$counter
#&gt; [1] 55

gmm &lt;- gmm_obj_wrap(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  printLevel = 2
)
#&gt; gmm objective: 29.3544
#&gt; 	 theta (RC): 0.33 2.45 0.02 0.24 
#&gt; 	 theta (demogr.): 5.48 15.89 -0.25 1.26 0 -1.2 0 0 0.2 0 0.05 -0.81 0 2.63 0 0 
#&gt; 	 inner iterations: 55 
#&gt; 	 gradient: 9.8468 0.3171 363.5319 16.3598 10.6031 0.7028 42.5236 -3.4759 13.4982 -2.0231 10.9331 1.2851 -0.5714 
#&gt; [1] 29.35439

gmm$local_min
#&gt; [1] 29.35439
</code></pre>
<p>Printed distances in the contraction mapping are maximum absolute distances between the current vector of mean utilities and the previous one.</p>
<p>For any \(\theta_2\), you can compute predicted shares:</p>
<pre><code class="language-r">shareObj &lt;- getShareInfo(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  printLevel = 4
)
#&gt; Mean utility (delta) is used as provided in the BLP_data() function.

shareObj$shares[1:6]
#&gt; cereal_1_market_1 cereal_2_market_1 cereal_3_market_1 cereal_4_market_1 
#&gt;       0.052856545       0.002175260       0.006105588       0.001529422 
#&gt; cereal_5_market_1 cereal_6_market_1 
#&gt;       0.001571742       0.003654192
</code></pre>
<p>The object contains a list of outputs that are useful for further economic analysis. For example, the list element <code>sij</code> contains share probabilities for every individual and needs to be given to calculate elasticities.</p>
<p>The gradient contains two important building blocks as explained in the appendix of @Nevo2001:</p>
<ul>
<li>
<p>\(\frac{\partial s_{ijt}}{\partial \theta_2}\) , i.e. the derivative of individual \(i\)’s share of product \(j\) in market \(t\) with respect to non-linear parameters</p>
</li>
<li>
<p>\(\frac{\partial s_{ijt}}{\partial \delta}\) , i.e. the derivative of individual \(i\)’s share of product \(j\) in market \(t\) with respect to mean utilities</p>
</li>
</ul>
<p>Both are used to compute the jacobian and are easy to obtain with the package as the following example demonstrates:</p>
<pre><code class="language-r"># market 2:
derivatives1 &lt;- dstdtheta_wrap(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  market = &quot;market_2&quot;
)
#&gt; Mean utility (delta) is used as provided in the BLP_data() function.
derivatives2 &lt;- dstddelta_wrap(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  market = &quot;market_2&quot;
)
#&gt; Mean utility (delta) is used as provided in the BLP_data() function.

jac_mkt2 &lt;- -solve(derivatives2) %*% derivatives1

jac_mkt2[1:5, 1:4]
#&gt;                      unobs_sd*(Intercept) unobs_sd*price unobs_sd*sugar
#&gt; meanUtility_cereal_1           -0.3935523    0.010936676      -1.430109
#&gt; meanUtility_cereal_2           -0.5385401    0.002959190      -8.608901
#&gt; meanUtility_cereal_3           -0.4567829    0.003935221      -2.612346
#&gt; meanUtility_cereal_4           -0.7766701   -0.022430917      -1.567758
#&gt; meanUtility_cereal_5           -0.7821670   -0.085051524      -2.722660
#&gt;                      unobs_sd*mushy
#&gt; meanUtility_cereal_1    -0.47865751
#&gt; meanUtility_cereal_2    -0.20678073
#&gt; meanUtility_cereal_3    -0.43499042
#&gt; meanUtility_cereal_4    -0.04046717
#&gt; meanUtility_cereal_5    -0.04388127

# all markets
jacobian_nevo &lt;- getJacobian_wrap(
  blp_data = cereal_data,
  par_theta2 = theta_guesses_cereal,
  printLevel = 2
)
#&gt; Mean utility (delta) is used as provided in the BLP_data() function.

jacobian_nevo[25:29, 1:4] # compare to jac_mkt2
#&gt;                   unobs_sd*(Intercept) unobs_sd*price unobs_sd*sugar
#&gt; cereal_1_market_2           -0.3935523    0.010936676      -1.430109
#&gt; cereal_2_market_2           -0.5385401    0.002959190      -8.608901
#&gt; cereal_3_market_2           -0.4567829    0.003935221      -2.612346
#&gt; cereal_4_market_2           -0.7766701   -0.022430917      -1.567758
#&gt; cereal_5_market_2           -0.7821670   -0.085051524      -2.722660
#&gt;                   unobs_sd*mushy
#&gt; cereal_1_market_2    -0.47865751
#&gt; cereal_2_market_2    -0.20678073
#&gt; cereal_3_market_2    -0.43499042
#&gt; cereal_4_market_2    -0.04046717
#&gt; cereal_5_market_2    -0.04388127
</code></pre>
<h1>Another Example: Merger Analysis with BLP’s car data</h1>
<p>Analyzing a hypothetical merger is demonstrated by the car data of @BLP1995. In this case, the preparation of product data comprises the computation of instruments as a function of product characteristics of competitors’ products (for details, check @BLP1995). This example is based on data and documentation of @KM2014.</p>
<pre><code class="language-r"># add owner matix to productData
own_pre &lt;- dummies_cars
colnames(own_pre) &lt;- paste0(&quot;company&quot;, 1:26)
productData_cars &lt;- cbind(productData_cars, own_pre)

# construct instruments
nobs &lt;- nrow(productData_cars)
X &lt;- data.frame(
  productData_cars$const, productData_cars$hpwt,
  productData_cars$air, productData_cars$mpg, productData_cars$space
)

sum_other &lt;- matrix(NA, nobs, ncol(X))
sum_rival &lt;- matrix(NA, nobs, ncol(X))
sum_total &lt;- matrix(NA, nobs, ncol(X))

for (i in 1:nobs) {
  other_ind &lt;- productData_cars$firmid == productData_cars$firmid[i] &amp;
    productData_cars$cdid == productData_cars$cdid[i] &amp;
    productData_cars$id != productData_cars$id[i]
  rival_ind &lt;- productData_cars$firmid != productData_cars$firmid[i] &amp;
    productData_cars$cdid == productData_cars$cdid[i]
  total_ind &lt;- productData_cars$cdid == productData_cars$cdid[i]

  sum_other[i, ] &lt;- colSums(X[other_ind == 1, ])
  sum_rival[i, ] &lt;- colSums(X[rival_ind == 1, ])
  sum_total[i, ] &lt;- colSums(X[total_ind == 1, ])
}

colnames(sum_other) &lt;- paste0(&quot;IV&quot;, 1:5)
colnames(sum_rival) &lt;- paste0(&quot;IV&quot;, 6:10)
productData_cars &lt;- cbind(productData_cars, sum_other, sum_rival)
head(productData_cars)
#&gt;   firmid cdid  id const    price      hpwt air   mpg  space        share
#&gt; 1     15    1 129     1 4.935802 0.5289969   0 1.697 1.1502 0.0010512928
#&gt; 2     15    1 130     1 5.516049 0.4943244   0 1.740 1.2780 0.0006700762
#&gt; 3     15    1 132     1 7.108642 0.4676134   0 1.543 1.4592 0.0003405273
#&gt; 4     15    1 134     1 6.839506 0.4265403   0 1.517 1.6068 0.0005222419
#&gt; 5     15    1 136     1 8.928395 0.4524887   0 1.352 1.6458 0.0004424231
#&gt; 6     19    1 138     1 7.153086 0.4508706   0 1.552 1.6224 0.0027560592
#&gt;   company1 company2 company3 company4 company5 company6 company7 company8
#&gt; 1        0        0        0        0        0        0        0        0
#&gt; 2        0        0        0        0        0        0        0        0
#&gt; 3        0        0        0        0        0        0        0        0
#&gt; 4        0        0        0        0        0        0        0        0
#&gt; 5        0        0        0        0        0        0        0        0
#&gt; 6        0        0        0        0        0        0        0        0
#&gt;   company9 company10 company11 company12 company13 company14 company15
#&gt; 1        0         0         0         0         0         0         1
#&gt; 2        0         0         0         0         0         0         1
#&gt; 3        0         0         0         0         0         0         1
#&gt; 4        0         0         0         0         0         0         1
#&gt; 5        0         0         0         0         0         0         1
#&gt; 6        0         0         0         0         0         0         0
#&gt;   company16 company17 company18 company19 company20 company21 company22
#&gt; 1         0         0         0         0         0         0         0
#&gt; 2         0         0         0         0         0         0         0
#&gt; 3         0         0         0         0         0         0         0
#&gt; 4         0         0         0         0         0         0         0
#&gt; 5         0         0         0         0         0         0         0
#&gt; 6         0         0         0         1         0         0         0
#&gt;   company23 company24 company25 company26 IV1       IV2 IV3    IV4     IV5 IV6
#&gt; 1         0         0         0         0   4  1.840967   0  6.152  5.9898  87
#&gt; 2         0         0         0         0   4  1.875639   0  6.109  5.8620  87
#&gt; 3         0         0         0         0   4  1.902350   0  6.306  5.6808  87
#&gt; 4         0         0         0         0   4  1.943423   0  6.332  5.5332  87
#&gt; 5         0         0         0         0   4  1.917475   0  6.497  5.4942  87
#&gt; 6         0         0         0         0  28 16.964809   0 44.328 46.1233  63
#&gt;        IV7 IV8     IV9     IV10
#&gt; 1 44.55554   0 150.386 125.5613
#&gt; 2 44.55554   0 150.386 125.5613
#&gt; 3 44.55554   0 150.386 125.5613
#&gt; 4 44.55554   0 150.386 125.5613
#&gt; 5 44.55554   0 150.386 125.5613
#&gt; 6 29.50982   0 112.355  84.9556

# To show similarities between implementations of other authors,
# the variable &quot;const&quot; is used, although constants are considered by default.
blps_model &lt;- as.formula(&quot;share ~  0 + const + price + hpwt + air + mpg + space |
                        0 + const + hpwt + air + mpg + space |
                        0 + price + const + hpwt + air + mpg |
                        0 + IV1 + IV2 + IV3 + IV4 + IV5 + IV6 + IV7 + IV8 + IV9 + IV10&quot;)

car_data &lt;- BLP_data(
  model = blps_model,
  market_identifier = &quot;cdid&quot;,
  product_identifier = &quot;id&quot;,
  additional_variables = paste0(&quot;company&quot;, 1:26), # check reordering works
  productData = productData_cars,
  blp_inner_tol = 1e-9,
  blp_inner_maxit = 5000,
  integration_method = &quot;MLHS&quot;,
  integration_accuracy = 50, integration_seed = 48
)
#&gt; Mean utility (variable name: `delta`) is initialized with 0 because of missing or invalid par_delta argument.
</code></pre>
<p>In the next step, starting guesses for random coefficients are generated from a standard normal distribution. The estimation of the model works like before.</p>
<pre><code class="language-r">set.seed(121)
theta_guesses &lt;- matrix(rnorm(5))
rownames(theta_guesses) &lt;- c(&quot;price&quot;, &quot;const&quot;, &quot;hpwt&quot;, &quot;air&quot;, &quot;mpg&quot;)
colnames(theta_guesses) &lt;- &quot;unobs_sd&quot;


car_est &lt;- estimateBLP(
  blp_data = car_data,
  par_theta2 = theta_guesses,
  solver_method = &quot;BFGS&quot;, solver_maxit = 1000, solver_reltol = 1e-6,
  extremumCheck = FALSE, printLevel = 0
)
#&gt; blp_data were prepared with the following arguments:
#&gt; BLP_data(model = blps_model, market_identifier = &quot;cdid&quot;, product_identifier = &quot;id&quot;, 
#&gt;     additional_variables = paste0(&quot;company&quot;, 1:26), productData = productData_cars, 
#&gt;     integration_accuracy = 50, integration_method = &quot;MLHS&quot;, integration_seed = 48, 
#&gt;     blp_inner_tol = 1e-09, blp_inner_maxit = 5000)
#&gt; ------------------------------------------ 
#&gt; Solver message: Successful convergence 
#&gt; ------------------------------------------ 
#&gt; Final GMM evaluation at optimal parameters: 
#&gt; gmm objective: 131.2733
#&gt; 	 theta (RC): -0.42 -8.59 1.27 -0.1 1.07 
#&gt; 	 theta (demogr.):  
#&gt; 	 inner iterations: 67 
#&gt; 	 gradient: -18.9159 3.6499 27.2623 -8.5398 -28.9531 
#&gt; Using the heteroskedastic asymptotic variance-covariance matrix...

summary(car_est)
#&gt; 
#&gt; Data information:
#&gt; 
#&gt; 	 20 market(s) with 2217 products 
#&gt; 	 6 linear coefficient(s) (5 exogenous coefficients) 
#&gt; 	 5 non-linear parameters related to random coefficients 
#&gt; 	 0 demographic variable(s) 
#&gt; 
#&gt; Estimation results:
#&gt; 
#&gt;  Linear Coefficients
#&gt;          Estimate Std. Error    t value     Pr(&gt;|t|)
#&gt; const -13.0980731  1.0748672 -12.185759 3.701894e-34
#&gt; price  -0.9049313  0.1609564  -5.622213 1.885269e-08
#&gt; hpwt    2.1752674  0.8598893   2.529706 1.141581e-02
#&gt; air     1.4011076  0.2567444   5.457207 4.836818e-08
#&gt; mpg    -0.7994763  0.6366915  -1.255673 2.092345e-01
#&gt; space   3.1465811  0.3542019   8.883580 6.474222e-19
#&gt; 
#&gt;  Random Coefficients
#&gt;                  Estimate Std. Error    t value     Pr(&gt;|t|)
#&gt; unobs_sd*price -0.4150985 0.08593854 -4.8301784 1.364108e-06
#&gt; unobs_sd*const -8.5907908 2.19917403 -3.9063715 9.369243e-05
#&gt; unobs_sd*hpwt   1.2712851 0.41076258  3.0949390 1.968534e-03
#&gt; unobs_sd*air   -0.1005375 0.67001283 -0.1500531 8.807227e-01
#&gt; unobs_sd*mpg    1.0652496 0.48637023  2.1902032 2.850950e-02
#&gt; 
#&gt;  Wald Test
#&gt; 45.1733 on  5 DF, p-value: 1.33780381283636e-08 
#&gt; 
#&gt; Computational Details: 
#&gt; 	 Solver converged with 187 iterations to a minimum at 131.2733 .
#&gt; 	 Local minima check: NA
#&gt; 	 stopping criterion outer loop: 1e-06
#&gt; 	 stopping criterion inner loop: 1e-09
#&gt; 	 Market shares are integrated with MLHS and 50 draws. 
#&gt; 	 Method for standard errors: heteroskedastic
</code></pre>
<p>Next, all parameters that are required by the subsequent merger analysis are extracted. Note that all extracted data is based on the estimation object <code>car_est</code> or the data object <code>car_data</code> to maintain data consistency (for example, the order of data in <code>product_data_cars</code> might differ from <code>car_data</code>). Moreover, mean utilities are updated in <code>car_data</code> by the values in the estimation object <code>car_est</code>.</p>
<pre><code class="language-r">## Pre-Merger data
own_pre &lt;- as.matrix(car_data$data$additional_data[, paste0(&quot;company&quot;, 1:26)])
delta_pre &lt;- car_est$delta
theta1_price &lt;- car_est$theta_lin[&quot;price&quot;, ]
theta2_price &lt;- car_est$theta_rc[&quot;unobs_sd*price&quot;]
theta2_all &lt;- matrix(car_est$theta_rc)
rownames(theta2_all) &lt;- c(&quot;price&quot;, &quot;const&quot;, &quot;hpwt&quot;, &quot;air&quot;, &quot;mpg&quot;)
colnames(theta2_all) &lt;- &quot;unobs_sd&quot;

## update mean utility in data ( always use update_BLP_data() to update data object to maintain consistent data )
delta_data &lt;- data.frame(
  &quot;id&quot; = car_data$parameters$product_id,
  &quot;cdid&quot; = car_data$parameters$market_id,
  &quot;delta&quot; = delta_pre
)
car_data_updated &lt;- update_BLP_data(
  data_update = delta_data,
  blp_data = car_data
)
#&gt; Mean utility variable delta has been updated.
</code></pre>
<p>In the next step, an estimate for marginal costs \(mc\) <strong>before</strong> the merger is computed. The following is based on the FOC of a Bertrand equilibrium with prices \(p\) before the merger:</p>
<p>$$ p^{pre} - \widehat{mc} = \Omega^{pre}(p^{pre})^{-1} \hat{s}(p^{pre}) $$
\(\Omega^{pre}(p^{pre})^{-1}\) is defined marketwise as the inverse of</p>
<p>$$ \Omega^{pre}(p^{pre}) =
\pmatrix{
-\frac{\partial s_{1}}{\partial p_{1}} (p^{pre}) \cdot D_{1,1}  &amp; -\frac{\partial s_{2}}{\partial p_{1}} (p^{pre}) \cdot D_{1,2} &amp; \cdots &amp;  -\frac{\partial s_{j}}{\partial p_{1}} (p^{pre}) \cdot D_{1,j} &amp; \cdots &amp; -\frac{\partial s_{J}}{\partial p_{1}} (p^{pre}) \cdot D_{1,J}\
-\frac{\partial s_{1}}{\partial p_{2}} (p^{pre}) \cdot  D_{2,1} &amp; -\frac{\partial s_{2}}{\partial p_{2}} (p^{pre}) \cdot  D_{2,2} &amp; \cdots &amp; -\frac{\partial s_{j}}{\partial p_{2}} (p^{pre}) \cdot D_{2,j} &amp; \cdots &amp; -\frac{\partial s_{J}}{\partial p_{2}} (p^{pre}) \cdot  D_{2,J}\
\vdots  &amp; \vdots  &amp; \ddots &amp;   \vdots     &amp;  \ddots      &amp; \vdots\
-\frac{\partial s_{1}}{\partial p_{k}} (p^{pre}) \cdot D_{k,1}  &amp; -\frac{\partial s_{2}}{\partial p_{k}} (p^{pre}) \cdot D_{k,2}  &amp; \cdots &amp; -\frac{\partial s_{j}}{\partial p_{k}} (p^{pre}) \cdot D_{k,j}  &amp;  \cdots &amp;
-\frac{\partial s_{J}}{\partial p_{k}} (p^{pre}) \cdot D_{k,J}\
\vdots  &amp; \vdots  &amp; \ddots &amp;   \vdots     &amp;    \ddots    &amp; \vdots\
-\frac{\partial s_{1}}{\partial p_{J}} (p^{pre}) \cdot  D_{J,1} &amp; -\frac{\partial s_{2}}{\partial p_{J}} (p^{pre}) \cdot  D_{J,2} &amp; \cdots &amp; -\frac{\partial s_{j}}{\partial p_{J}} (p^{pre}) \cdot  D_{J,j}&amp; \cdots &amp; -\frac{\partial s_{J}}{\partial p_{J}} (p^{pre}) \cdot  D_{J,J}\
}
$$</p>
<p>with
$$D_{k,j} =  \begin{cases}  1 &amp; \text{if products k and j are produced by the same firm} \\ 0 &amp; \text{otherwise} \\ \end{cases}$$</p>
<p>Partial derivatives \(\frac{\partial s_j}{\partial p_k}\) can be calculated based on the elasticity \(\eta_{jk} = \frac{\partial s_j }{\partial p_k }\frac{ p_k}{ s_j}\), so
$$ \frac{\partial s_j}{\partial p_k} = \eta_{jk} \cdot \frac{ s_j}{ p_k} $$</p>
<p>In the following code chunk, these objects in a market <code>i</code> are labeled as follows:</p>
<ul>
<li><code>own_prod_pre_i</code> ($D_{k,j}$)</li>
<li><code>elasticities_i</code> ($\eta_{jk}$)</li>
<li><code>derivatives_i</code> ($\eta_{jk} \cdot \frac{ s_j}{ p_k}$)</li>
<li><code>-solve(t(derivatives_i) * own_prod_pre_i)</code> ($\Omega^{pre}(p^{pre})^{-1}$)</li>
<li><code>shareObj$shares</code> ($\hat{s}(p^{pre})$).</li>
</ul>
<pre><code class="language-r">## calculate sij
shareObj &lt;- getShareInfo(
  blp_data = car_data_updated,
  par_theta2 = theta2_all,
  printLevel = 0
)

## computation of marginal costs
market_id &lt;- car_data$parameters$market_id
nmkt &lt;- length(unique(market_id))
markups &lt;- numeric(length(market_id))

sh &lt;- shareObj$shares
prices_pre &lt;- car_data$data$X_rand[, &quot;price&quot;]


for (i in 1:nmkt) {
  mkt_ind &lt;- market_id == i
  share_i &lt;- sh[ mkt_ind ]
  price_pre_i &lt;- prices_pre[ mkt_ind ]
  scalar_i &lt;- matrix(1 / share_i) %*% matrix(price_pre_i, nrow = 1)
  elasticities_i &lt;- get_elasticities(
    blp_data = car_data_updated,
    share_info = shareObj,
    theta_lin = theta1_price,
    variable = &quot;price&quot;,
    market = i,
    printLevel = 0
  )

  derivatives_i &lt;- elasticities_i / scalar_i # partial derivatives of shares wrt price
  own_pre_i &lt;- own_pre[ mkt_ind, ]
  own_prod_pre_i &lt;- own_pre_i %*% t(own_pre_i) # if element (i,j) equals 1, that means that prod i and j are produced by same firm
  markups[mkt_ind] &lt;- c(-solve(t(derivatives_i) * own_prod_pre_i) %*% share_i)
}
marg_cost &lt;- prices_pre - markups
</code></pre>
<p>The ownership matrix is adjusted to implement a hypothetical merger between Chrysler and GM:</p>
<pre><code class="language-r"># Merger between company 16 and 19 (i.e. GM and Chrysler)
prices_post &lt;- numeric(2217)
own_post &lt;- cbind(
  own_pre[, 1:15],
  own_pre[, 16] + own_pre[, 19],
  own_pre[, 17:18],
  own_pre[, 20:26]
)
</code></pre>
<p>To analyze the effect on prices the FOC of the new equilibrium must be solved:
$$ p^{post} - \widehat{mc} = \Omega^{post}(p^{post})^{-1} \hat{s}(p^{post}) $$</p>
<p>The solution of this set of non-linear equations is obtained by the function <code>foc_bertrand_mkt</code> and the package <code>nleqslv</code>:</p>
<pre><code class="language-r">foc_bertrand_mkt &lt;- function(par, own_prod, blp_data, mkt, marg_cost, theta_lin, theta_rc) {
  # argument par: candidate for post merger prices
  # arguments own_prod, blp_data, mkt, marg_cost, theta_lin, theta_rc: see previous code blocks

  # post merger updates: update the BLP_data object for market i
  tmp &lt;- data.frame(
    &quot;id&quot; = blp_data$parameters$product_id,
    &quot;cdid&quot; = blp_data$parameters$market_id,
    &quot;delta&quot; = blp_data$data$delta,
    &quot;price&quot; = blp_data$data$X_rand[, &quot;price&quot;]
  )

  market_ind &lt;- blp_data$parameters$market_id == mkt
  delta_old &lt;- blp_data$data$delta
  prices_pre &lt;- blp_data$data$X_rand[, &quot;price&quot;]
  tmp$price[ market_ind ] &lt;- par
  tmp$delta[ market_ind ] &lt;- delta_old[market_ind] - prices_pre[market_ind] * theta_lin + par * theta_lin


  new_blp_data &lt;- update_BLP_data(
    blp_data = blp_data,
    data_update = tmp
  )

  ShareObj &lt;- getShareInfo(
    blp_data = new_blp_data,
    par_theta2 = theta_rc,
    printLevel = 0
  )

  implied_shares &lt;- as.matrix(ShareObj$shares[market_ind])

  elasticities_post_mkt &lt;- get_elasticities(
    blp_data = new_blp_data,
    share_info = ShareObj,
    theta_lin = theta_lin,
    variable = &quot;price&quot;,
    market = mkt,
    printLevel = 0
  )

  scalar_mkt &lt;- matrix(1 / implied_shares) %*% matrix(par, nrow = 1)
  derivatives_mkt &lt;- elasticities_post_mkt / scalar_mkt

  markups_post &lt;- c(-solve(t(derivatives_mkt) * own_prod) %*% implied_shares)
  differences &lt;- par - marg_cost[market_ind] - markups_post

  return(differences)
}
</code></pre>
<p>Finally, the function is used to compute the new equilibrium:</p>
<pre><code class="language-r">library(nleqslv) # to solve non linear first order conditions
for (i in 1:nmkt) {
  mkt_ind &lt;- market_id == i
  own_post_i &lt;- own_post[ mkt_ind, ]
  own_prod_post_i &lt;- own_post_i %*% t(own_post_i)
  price_pre_i &lt;- prices_pre[ mkt_ind ]

  solution &lt;- nleqslv(
    x = price_pre_i, foc_bertrand_mkt, # startingguesses: price_pre_i
    own_prod = own_prod_post_i,
    blp_data = car_data_updated,
    mkt = i,
    marg_cost = marg_cost,
    theta_lin = theta1_price,
    theta_rc = theta2_all
  )

  prices_post[ market_id == i ] &lt;- solution$x
}
</code></pre>
<h1>References</h1>


<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/center-img.min.js" async></script>
</body>

</html>
